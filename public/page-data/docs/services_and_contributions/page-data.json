{"componentChunkName":"component---src-templates-doc-js","path":"/docs/services_and_contributions","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Services and Contributions"},"html":"<h1 id=\"服务和贡献\" style=\"position:relative;\"><a href=\"#%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%B4%A1%E7%8C%AE\" aria-label=\"服务和贡献 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>服务和贡献</h1>\n<p>本节我们讲述如何使用平台和 <a href=\"https://theia-ide.org/docs/extensions#theia-extensions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Theia 扩展</a> 提供的服务，以及如何通过扩展点为 Theia 工作台扩展能力。</p>\n<p><strong>服务</strong>是为消费者提供功能的对象。服务和消费者之间由接口约定描述。任何服务的实现都必须根据接口来实现。Theia 的任何扩展都可以提供和/或消费服务。Theia 内部的扩展提供了一套默认服务，如，<a href=\"https://theia-ide.org/docs/message_service/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">MessageService</code></a>。当然你也可以提供和消费自己自定义的扩展服务。</p>\n<p><strong>扩展点</strong>通过自定义钩子对外提供扩展能力。扩展点是由贡献者需要实现的接口定义的，例如：<code class=\"language-text\">CommandContribution</code>。定义扩展点的扩展将挂载该贡献，例如，将扩展的命令添加到 Theia 工作台上。</p>\n<p>扩展点像服务一样，可以被任意扩展贡献和定义。Theia 定义了一组默认的扩展点，例如，可将命令或菜单添加到 Theia 工作台中，你也可以定义自己的扩展点。</p>\n<p>服务和扩展点的使用需要扩展之间的约定，为了避免对实现类的直接依赖，Theia 使用了依赖性注入。</p>\n<img src=\"/dependency-injection.png\" alt=\"Dependency Injection Overview\" style=\"max-width: 525px\">\n<p>在下面的章节中，我们将对依赖性注入、服务、贡献以及如何定义扩展点进行简要概述。</p>\n<h2 id=\"依赖注入-di\" style=\"position:relative;\"><a href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-di\" aria-label=\"依赖注入 di permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>依赖注入 (DI)</h2>\n<p>Theia 用依赖注入框架[InversifyJS]（<a href=\"http://inversify.io/%EF%BC%89%E6%9D%A5%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%89%A9%E5%B1%95%E7%82%B9%E3%80%82\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://inversify.io/）来连接不同的服务和扩展点。</a></p>\n<p>依赖注入将服务的消费者--即这些消费者的依赖关系--与服务的实际创建和引用进行解耦。举例来说，如果你想使用一个服务，你既不需要实例化它，也不需要从某个地方手动引用它。相反，依赖注入容器会在组件创建时注入服务。依赖注入容器为你解决依赖性问题，如果有必要，甚至可以在运行中实例化它。这样一来，服务的消费者就不需要担心它们来自哪里，可以在后续轻松更改服务的实际实现，而不需要改变消费者。依赖注入容器基于启动时容器模块提供的配置运行。</p>\n<p>我们将在下面的\"服务\"和\"扩展点\"部分给出依赖注入的使用案例。</p>\n<p>依赖注入是 Theia 的重要组成部分，我们强烈建议学习 [InversifyJS]（<a href=\"http://inversify.io/%EF%BC%89%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%82%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82%E8%AF%B7%E5%8F%82%E8%80%83%5B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%9C%A8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://inversify.io/）的基础知识。更多细节请参考[这篇文章：依赖注入在</a> Theia 中的工作原理](<a href=\"https://eclipsesource.com/blogs/2018/11/28/how-to-inversify-in-eclipse-theia/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://eclipsesource.com/blogs/2018/11/28/how-to-inversify-in-eclipse-theia/</a>)</p>\n<h2 id=\"使用服务\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1\" aria-label=\"使用服务 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用服务</h2>\n<p>要在 Theia 中使用服务，可以用依赖注入的方式，将其作为一个依赖关系进行注入。依赖关系通常由所需服务的接口来指定，你甚至可以不依赖任何实现，调用者只需知道接口。这使提供实现的组件可以无缝地更改服务。你甚至可以覆盖一个服务的现有默认实现而不破坏任何服务消费者。</p>\n<p>为了从依赖注入容器中获得参数，需要用标识符（一个字符串）来注解。另外，服务提供者也会用标识符来发布可用的服务。当用依赖注入请求具有特定标识符的参数时，依赖注入上下文将查找并返回相应服务的实例。为方便起见，服务提供者通常使用 Symbol 作为标识符，它的名称与各自的服务接口本身完全相同。下面的例子中，'@inject(MessageService)'是一个符号（服务标识符），而 'private readonly messageService: MessageService' 是指服务的接口。</p>\n<p>服务或者说依赖关系可以作为一个字段，在构造函数或初始化函数中被注入（见下面的代码例子）：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// Injection in the constructor.</span>\n<span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">inject</span></span><span class=\"token punctuation\">(</span>MessageService<span class=\"token punctuation\">)</span> <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> messageService<span class=\"token operator\">:</span> MessageService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n \n<span class=\"token comment\">// Injection as a field.</span>\n<span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">inject</span></span><span class=\"token punctuation\">(</span>MessageService<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">readonly</span> messageService<span class=\"token operator\">!</span><span class=\"token operator\">:</span> MessageService<span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// Injection in an initialization function (will be called after the constructor and after injecting fields.</span>\n<span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">postConstruct</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">async</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">inject</span></span><span class=\"token punctuation\">(</span>MessageService<span class=\"token punctuation\">)</span> <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> messageService<span class=\"token operator\">:</span> MessageService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>需注意，注入只对依赖注入容器创建的组件有效，它们必须用 <code class=\"language-text\">@injectable</code> 标记（见下面的代码示例）。此外，它们必须在依赖注入上下文中注册（例子见下一节）。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">injectable</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyContribution</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">SomeContributionInterface</span></code></pre></div>\n<h2 id=\"实现扩展点\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%82%B9\" aria-label=\"实现扩展点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现扩展点</h2>\n<p>Theia 的扩展点定义了需要实现的接口，例如\"CommandContribution\"。扩展必须提供这个接口的实现，并以 \"@injectable\" 标记，例如：</p>\n<p><strong>mycommand-contribution.ts</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">injectable</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyCommandContribution</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">CommandContribution</span></code></pre></div>\n<p>此外，贡献必须被绑定在依赖注入容器中，这样扩展点提供者就可以获得我们的贡献，确切地说，是获取它的注入。绑定是在扩展的容器（container module）中完成的，它将实现与扩展接口绑定，或者从技术上讲，与代表该接口的符号绑定（见下面的例子）。</p>\n<p><strong>helloworld-frontend-module.ts</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ContainerModule</span><span class=\"token punctuation\">(</span>bind <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// add your contribution bindings here</span>\n   <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>CommandContribution<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">to</span><span class=\"token punctuation\">(</span>HelloworldCommandContribution<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>关于服务和扩展点的使用，请参见<a href=\"https://theia-ide.org/docs/commands_keybindings/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">命令/菜单/快捷键绑定</a>中的例子。</p>\n<h2 id=\"定义扩展点\" style=\"position:relative;\"><a href=\"#%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E7%82%B9\" aria-label=\"定义扩展点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>定义扩展点</h2>\n<p>如果扩展想提供钩子让别人来贡献，他们应该定义一个 <em>扩展点</em>，<em>扩展点</em> 只是一个接口，供其他人实现，扩展将在需要时委托给他们。</p>\n<p>例如，\"OpenerService\" 定义了一个扩展点，允许其他人注册 \"OpenHandler\"。可参考 <a href=\"https://github.com/eclipse-theia/theia/blob/master/packages/core/src/browser/opener-service.ts\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这里的代码</a>。</p>\n<p>Theia 已经内置了很多扩展点，可以通过 \"bindContributionProvider\" 来查看有哪些已存在的扩展点。</p>\n<h2 id=\"贡献提供者\" style=\"position:relative;\"><a href=\"#%E8%B4%A1%E7%8C%AE%E6%8F%90%E4%BE%9B%E8%80%85\" aria-label=\"贡献提供者 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>贡献提供者</h2>\n<p>贡献提供者基本上可视为贡献的容器，而贡献是一个绑定类型的实例。</p>\n<p>要把一个类型绑定到贡献提供者，通用的方式，可以这样做：</p>\n<p>(From messaging-module.ts)</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> messagingModule <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ContainerModule</span><span class=\"token punctuation\">(</span>bind <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token generic-function\"><span class=\"token function\">bind</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>BackendApplicationContribution<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>BackendApplicationContribution<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">to</span><span class=\"token punctuation\">(</span>MessagingContribution<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">bindContributionProvider</span><span class=\"token punctuation\">(</span>bind<span class=\"token punctuation\">,</span> ConnectionHandler<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最后一行，把贡献提供者绑定到一个包含所有 ConnectionHandler 的绑定实例。</p>\n<p>它是这样使用的：</p>\n<p>(From messaging-module.ts)</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span> <span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">inject</span></span><span class=\"token punctuation\">(</span>ContributionProvider<span class=\"token punctuation\">)</span> <span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">named</span></span><span class=\"token punctuation\">(</span>ConnectionHandler<span class=\"token punctuation\">)</span> <span class=\"token keyword\">protected</span> <span class=\"token keyword\">readonly</span> handlers<span class=\"token operator\">:</span> ContributionProvider<span class=\"token operator\">&lt;</span>ConnectionHandler<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里我们注入一个用之前 <code class=\"language-text\">bindContributionProvider</code> 绑定的，名称为 ConnectionHandler 的贡献提供者。</p>\n<p>这使得任何人都可以绑定 ConnectionHandler，现在当消息传递模块启动时，所有的 ConnectionHandler 都将被启动。</p>","fields":{"slug":"services_and_contributions"}}},"pageContext":{"slug":"services_and_contributions"}},"staticQueryHashes":["2468095761"]}